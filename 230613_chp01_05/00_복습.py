# 시퀀스 자료형
"""
우리가 지금까지 사용했던 리스트, 튜플, range, 문자열을 잘 보면 공통점이 있습니다. 이들 모두 값이 연속적(sequence)으로 이어져 있다는 점입니다.

파이썬에서는 리스트, 튜플, range, 문자열처럼 값이 연속적으로 이어진 자료형을 시퀀스 자료형(sequence types)라고 부릅니다.

## 시퀀스 자료형의 공통 기능 사용하기

### 특정 값이 있는지 확인하기
먼저 시퀀스 객체 안에 특정 값이 있는지 확인하는 방법부터 알아보겠습니다. 다음은 리스트 a에서 30과 100이 있는지 확인합니다.

* `값 in 시퀀스객체`
"""

a = [30, 100]  # [요소1, 요소2...]
print("30 in a :", 30 in a)  # 포함하면 True, 포함하지 않으면 False.
print("50 in a :", 50 in a)  # 포함하면 True, 포함하지 않으면 False.


"""시퀀스 객체에 in 연산자를 사용했을 때 특정 값이 있으면 True, 없으면 False가 나옵니다. 따라서 리스트 a에 30이 있으므로 True, 100이 없으므로 False가 나옵니다.

반대로 in 앞에 not을 붙이면 특정 값이 없는지 확인합니다.

* `값 not in 시퀀스객체`
"""
print("not 50 in a :", not (50 in a))  # bool 값을 반전시키는 not? not (False) -> True
print("50 not in a :", 50 not in a)  # 포함하지 않는다
print("30 not in a :", 30 not in a)  # 포함하지 않는다




"""이렇게 not in은 특정 값이 없으면 True, 있으면 False가 나옵니다.

물론 튜플, range, 문자열도 같은 방법으로 활용할 수 있습니다.
"""

text = "마제소바"  # 시퀀스 객체 -> 요소를 in으로 검사할 수 있는데... -> 문자열에서의 요소는 '한 글자'다.
print("'마' in text :", '마' in text)
print("'가' in text :", '가' in text)
# 문자열은 순서를 지킨 형태의 부분집합에 대해서 검색이 가능
print("'마제' in text :", '마제' in text)
print("'마소' in text :", '마소' in text)





"""### 시퀀스 객체 연결하기 (concat, concatenate)

시퀀스 객체는 + 연산자를 사용하여 객체를 서로 연결하여 새 객체를 만들 수 있습니다.

* `시퀀스객체1 + 시퀀스객체2`
"""

fruits = ["사과", "배", "포도"]
fruits2 = ["바나나", "샤인머스킷", "귤"]
print("fruits + fruits2 :", fruits + fruits2)
# print("fruits - fruits2 :", fruits - fruits2) # TypeError: unsupported operand type(s) for -: 'list' and 'list'
# Counter? 유사 시퀀스 자료형 주제에... - 연산자가 먹히는.
name = "김코딩"
hello = "안녕하세요!"
print(hello + " " + name)

# print(range(5, 12) + range(3, 9))  # TypeError: unsupported operand type(s) for +: 'range' and 'range'
# 이때는 range를 리스트 또는 튜플로 만들어서 연결하면 됩니다.
print(list(range(5, 12)) + list(range(3, 9)))


# 문자열은 + 연산자로 여러 문자열을 연결할 수 있습니다.

"""### 문자열에 숫자 연결하기"""

# 숫자는 시퀀스 자료형이 아님! -> 문자열과 +를 통해서 연결할 수 없음.

"""문자열에 정수를 연결하려고 하면 에러가 발생합니다(정수를 문자열로 변환할 수 없어서 TypeError가 발생합니다). 이 문제를 해결하려면 str을 사용하여 숫자(정수, 실수)를 문자열로 변환하면 됩니다.

* `'문자열' + str(정수)`
* `'문자열' + str(실수)`

"""

# print("저는 오늘부터 " + 20 + "살입니다")  # TypeError: can only concatenate str (not "int") to str
print("저는 오늘부터 " + str(20) + "살입니다")


"""### 시퀀스 객체 반복하기

이번에는 시퀀스 객체를 반복하는 방법입니다. `*` 연산자는 시퀀스 객체를 특정 횟수만큼 반복하여 새 시퀀스 객체를 만듭니다(0 또는 음수를 곱하면 빈 객체가 나오며 실수는 곱할 수 없습니다).

* `시퀀스객체 * 정수`
* `정수 * 시퀀스객체`
"""

l = [10, 20, 30]
print(l + l + l)
print(l * 3)
s = "안녕"
print(s * 100)

# 앞에서 range는 + 연산자로 객체를 연결할 수 없었죠? 마찬가지로 range는 * 연산자를 사용하여 반복할 수 없습니다.
# print(range(10) * 3)  # TypeError: unsupported operand type(s) for *: 'range' and 'int'
# 이때는 range를 리스트 또는 튜플로 만들어서 반복하면 됩니다.
print(list(range(10)) * 3)

# 문자열은 * 연산자를 사용하여 반복할 수 있습니다.

"""## 시퀀스 객체의 요소 개수 구하기

시퀀스 객체에는 요소가 여러 개 들어있죠? 이 요소의 개수(길이)를 구할 때는 len 함수를 사용합니다(len은 길이를 뜻하는 length에서 따왔습니다).

* `len(시퀀스객체)`

### 리스트와 튜플의 요소 개수 구하기
"""

l = [10, 20, 30, 40, 50]
print("len(l)", len(l))
t = (1, 2, 3, 4, 5)
print("len(t)", len(t))


"""### range의 숫자 생성 개수 구하기"""

# range에 len 함수를 사용하면 숫자가 생성되는 개수를 구합니다.
r = range(7, 792, 15)
print("len(r) :", len(r))

"""### 문자열의 길이 구하기"""

# 문자열도 시퀀스 자료형이므로 len 함수를 사용하면 됩니다.
s = "이브 프시케 그리고 푸른 수염"
print("len(s) :", len(s))

"""여기서 문자열의 길이는 공백까지 포함합니다. 단, 문자열을 묶은 따옴표는 제외합니다. 이 따옴표는 문자열을 표현하는 문법일 뿐 문자열 길이에는 포함되지 않습니다(문자열 안에 포함된 작은따옴표, 큰따옴표는 포함됨)."""

# 한글 문자열의 길이도 len으로 구하면 됩니다.

"""인덱스 사용하기

이번에는 시퀀스 객체에 들어있는 요소에 접근하는 방법을 알아보겠습니다. 시퀀스 객체의 각 요소는 순서가 정해져 있으며, 이 순서를 인덱스라고 부릅니다.

다음과 같이 시퀀스 객체에 `[ ](대괄호)`를 붙이고 [ ] 안에 각 요소의 인덱스를 지정하면 해당 요소에 접근할 수 있습니다.
"""

l = list(range(1, 11))
print("l", l)
# l이라고 하는 리스트에 있는 3번째 요소의 값을 불러오고 싶어요
print("l[3]", l[3])
# 인덱스는 0부터 시작
print("l[2]", l[2])
l2 = [3, 7, 2, 9, 1]
print(l2[1])

"""인덱스(index, 색인)는 위치 값을 뜻하는데 국어사전 옆면에 ㄱ, ㄴ, ㄷ으로 표시해 놓은 것과 비슷합니다. 여기서 주의할 점은 시퀀스 객체의 인덱스는 항상 0부터 시작한다는 점입니다(대다수의 프로그래밍 언어는 인덱스가 0부터 시작합니다). 따라서 리스트 a의 첫 번째 요소는 a[0]이 됩니다. 꼭 기억해두세요.

튜플, range, 문자열도 [ ]에 인덱스를 지정하면 해당 요소를 가져올 수 있습니다.
"""

# 튜플 b의 첫 번째(인덱스 0) 요소를 출력합니다.

"""range도 인덱스로 접근할 수 있습니다."""

# range의 세 번째(인덱스 2) 요소를 출력합니다.

"""문자열은 요소가 문자이므로 인덱스로 접근하면 문자가 나옵니다."""
hello = "welcome python"
# 문자열 hello의 여덟 번째 요소를 출력합니다.
print("hello[7]", hello[7])

"""### 시퀀스 객체에 인덱스를 지정하지 않으면?

시퀀스 객체에 인덱스를 지정하지 않은 상태는 해당 객체 전체를 뜻합니다. 따라서 다음과 같이 리스트 a를 출력하면 [ ]를 포함하여 리스트 전체가 출력됩니다.
"""



"""### 음수 인덱스 지정하기

지금까지 시퀀스 객체에 인덱스를 양의 정수와 0만 지정했습니다. 그러면 인덱스를 음수로 지정하면 어떻게 될까요?
"""
l = [5, 8, 13, 21, 34, 55]
print("l[0]", l[0])
print("l[-1]", l[-1])  # 맨 끝값
print("l[len(l)-1]", l[len(l)-1])  # 맨 끝값
# 어떠한 시퀀스 객체의 최대 인덱스는 len(시퀀스객체) - 1.
print("l[-6]", l[-6])  # l[0]
# print("l[-7]", l[-7]) # IndexError: list index out of range



"""튜플, range, 문자열도 음수 인덱스를 지정하면 뒤에서부터 요소에 접근합니다."""
print(s)
print(s[-1])
print(s[-3])
print(s[-16])



"""### 인덱스의 범위를 벗어나면?

시퀀스 객체를 만들면 요소의 개수는 정해져 있죠? 다음과 같이 리스트를 만든 뒤 범위를 벗어난 인덱스에 접근하면 어떻게 될까요?
"""



"""리스트 a의 요소 개수는 5개인데 a[5]와 같이 지정하면 리스트의 범위를 벗어나게 되므로 에러가 발생합니다. 왜냐하면 인덱스는 0부터 시작하므로 마지막 요소의 인덱스는 4이기 때문이죠. 즉, 마지막 요소의 인덱스는 시퀀스 객체의 요소 개수보다 1 작습니다. 이 부분은 시퀀스 객체를 사용할 때 자주 틀리는 부분이므로 꼭 기억해두세요.

마찬가지로 튜플, range, 문자열도 범위를 벗어난 인덱스를 지정하면 IndexError가 발생합니다.

### 마지막 요소에 접근하기

앞에서 시퀀스 객체에 인덱스를 -1로 지정하면 뒤에서 첫 번째 요소에 접근한다고 했죠? 바로 시퀀스 객체의 마지막 요소입니다.

그러면 시퀀스 객체의 마지막 요소에 접근하는 다른 방법은 없을까요? 다음과 같이 len 함수로 리스트의 길이를 구한 뒤 이 길이를 인덱스로 지정해보면 에러가 발생합니다.
"""





"""리스트 a의 인덱스는 0부터 4까지이므로 인덱스에 a의 길이 5를 지정하면 인덱스의 범위를 벗어나게 됩니다. 따라서 5가 아닌 4를 지정해야 마지막 문자가 나옵니다."""



# 인덱스에 len(a)를 넣으면?

# len(a)는 5이므로 인덱스가 범위를 벗어납니다. 이때는 len(a)에서 1을 빼주어야 인덱스가 범위를 벗어나지 않습니다.

"""### 요소에 값 할당하기

이제 시퀀스 객체의 요소에 값을 할당하는 방법을 알아보겠습니다. 시퀀스 객체는 [ ]로 요소에 접근한 뒤 =로 값을 할당합니다.

* `시퀀스객체[인덱스] = 값`
"""
# 인덱스를 통해서 시퀀스 객체 내부의 요소를 바꿔줄 수 있는 것 = 리스트
# 인덱스를 통해서 이미 존재하는 값(위치)에 새로운 값을 할당.

l = [0] * 5
print("l", l)
l[0] = 200
l[1] = 72
l[2] = 322
l[3] = 59
l[4] = 1121221
print("l", l)
# l[5] = 123123  # IndexError: list assignment index out of range

# 튜플의 [ ]에 인덱스를 지정한 뒤 값을 할당하면 에러가 발생합니다.

# range와 문자열도 안에 저장된 요소를 변경할 수 없습니다.



"""### del로 요소 삭제하기

이번에는 del로 시퀀스 객체의 요소를 삭제해보겠습니다. 요소 삭제는 다음과 같이 del 뒤에 삭제할 요소를 지정해주면 됩니다.

* `del 시퀀스객체[인덱스]`
"""

# 리스트를 만들고 세 번째 요소(인덱스 2)를 삭제해보겠습니다.

# 리스트와는 달리 튜플은 요소를 삭제할 수 없습니다.

# range와 문자열도 안에 저장된 요소를 삭제할 수 없습니다.

"""## 슬라이스 사용하기

시퀀스 자료형은 슬라이스라는 기능을 자주 사용합니다. 슬라이스(slice)는 무엇인가의 일부를 잘라낸다는 뜻인데, 시퀀스 슬라이스도 말 그대로 시퀀스 객체의 일부를 잘라냅니다.

* `시퀀스객체[시작인덱스:끝인덱스]`
"""
print(l)
print("l[1:3]", l[1:3])  # 끝점은 포함하지 않는다 (레인지처럼).
print("l[1:4]", l[1:4])  # 인덱스 1부터 인덱스 3(인덱스 4직전까지)
print(l)

"""[ ] 안에 시작 인덱스와 끝 인덱스를 지정하면 해당 범위의 리스트를 잘라서 가져올 수 있습니다. 여기서 주의할 점이 있는데, 끝 인덱스는 가져오려는 범위에 포함되지 않습니다. 따라서 끝 인덱스는 실제로 가져오려는 인덱스보다 1을 더 크게 지정해야 합니다. (끝 인덱스는 범위를 벗어난 인덱스를 지정할 수 있습니다)."""







"""슬라이스를 했을 때 실제로 가져오는 요소는 시작 인덱스부터 끝 인덱스 - 1까지입니다.

### 리스트의 중간 부분 가져오기

그럼 리스트의 중간 부분을 가져오는 방법을 자세히 알아보겠습니다.
"""





"""인덱스에서 -1은 뒤에서 첫 번째 요소를 뜻한다고 했죠? 끝 인덱스는 가져오려는 인덱스보다 1을 더 크게 지정한다고 했으므로 실제로는 뒤에서 두 번째(인덱스 -2) 요소인 80까지만 가져옵니다(음수는 숫자가 작을 수록 큰 수입니다. 그래서 -1은 -2보다 1이 더 큽니다).

### 인덱스 증가폭 사용하기

금까지 지정된 범위의 요소를 모두 가져왔죠? 슬라이스는 인덱스의 증가폭을 지정하여 범위 내에서 인덱스를 건너뛰며 요소를 가져올 수 있습니다.

다음은 인덱스를 3씩 증가시키면서 요소를 가져옵니다. 여기서 주의할 점은 인덱스의 증가폭이지 요소의 값 증가폭이 아니라는 점입니다.

* `시퀀스객체[시작인덱스:끝인덱스:인덱스증가폭]`
"""

a = list(range(5, 200, 15))
print(a)
print(a[2:8:3])

"""a[2:8:3]을 실행하니 [35, 80]이 나왔죠? 왜 이런 결과가 나왔을까요? 먼저 시작 인덱스가 2이므로 35부터 가져옵니다.
그리고 인덱스 증가폭을 3으로 지정했으므로 인덱스 5의 80, 인덱스 8의 125을 가져올 수 있습니다.
하지만, 끝 인덱스를 8로 지정했으므로 인덱스 7까지만 가져옵니다. 따라서 20과 50만 가져와서 [35, 80]이 나옵니다.

인덱스 증가폭을 지정하더라도 가져오려는 인덱스(끝 인덱스 - 1)를 넘어설 수 없다는 점을 꼭 기억해두세요.

만약 끝 인덱스 - 1과 증가한 인덱스가 일치한다면 해당 요소까지 가져올 수 있습니다. 다음은 끝 인덱스를 9로 지정하여 인덱스 8의 80까지 가져옵니다. 따라서 [35, 80, 125]이 나옵니다.
"""
print(a[2:9:3])


"""### 인덱스 생략하기

슬라이스를 사용할 때 시작 인덱스와 끝 인덱스를 생략할 수도 있습니다. 인덱스를 생략하는 방법은 시퀀스 객체의 길이를 몰라도 되기 때문에 자주 쓰이는 방식입니다. 주로 시퀀스 객체의 마지막 일부분만 출력할 때 사용합니다.

리스트 a에서 a[:7]과 같이 시작 인덱스를 생략하면 리스트의 처음부터 끝 인덱스 - 1(인덱스 6)까지 가져옵니다.

* `시퀀스객체[:끝인덱스]`
"""

print("a[0:7]", a[0:7])
print("a[:7]", a[:7])

"""그리고 a[7:]과 같이 끝 인덱스를 생략하면 시작 인덱스(인덱스 7)부터 마지막 요소까지 가져옵니다.

* `시퀀스객체[시작인덱스:]`
"""
print("a[7:]", a[7:])
print("a[7:len(a)]", a[7:len(a)])
print("a[7:-3]", a[7:-3])



"""또는, a[:]와 같이 시작 인덱스와 끝 인덱스를 둘다 생략하면 리스트 전체를 가져옵니다.

* `시퀀스객체[:]`

"""
print(a[:])
print(a[0:len(a)])


"""### 인덱스를 생략하면서 증가폭 사용하기

여기서 시작 인덱스 또는 끝 인덱스를 생략하면서 인덱스 증가폭을 지정하면 어떻게 될까요?

리스트 a에서 a[:7:2]와 같이 시작 인덱스를 생략하면서 인덱스 증가폭을 2로 지정하면 리스트의 처음부터 인덱스를 2씩 증가시키면서 끝 인덱스 - 1(인덱스 6)까지 요소를 가져옵니다.

* `시퀀스객체[:끝인덱스:증가폭]`
"""

print(a[:7:2])
print(a[0:7:2])

"""그리고 a[7::2]와 같이 끝 인덱스를 생략하면서 인덱스 증가폭을 2로 지정하면 시작 인덱스(인덱스 7)부터 인덱스를 2씩 증가시키면서 리스트의 마지막 요소까지 가져옵니다.

* `시퀀스객체[시작인덱스::증가폭]`
"""

print(a[7::2])
print(a[7:len(a):2])

"""또는, a[::2]와 같이 시작 인덱스와 끝 인덱스를 둘다 생략하면서 인덱스 증가폭을 2로 지정하면 리스트 전체에서 인덱스 0부터 2씩 증가하면서 요소를 가져옵니다.

* `시퀀스객체[::증가폭]`
"""

print(a[:])
print(a[::1])
print(a[::2])

"""a[:7:2]와 a[7::2]는 2씩 증가한 인덱스와 끝 인덱스 - 1이 일치하여 지정된 범위에 맞게 요소를 가져왔습니다. 하지만, a[::2]는 끝 인덱스가 9이므로 인덱스가 2씩 증가하더라도 8까지만 증가할 수 있습니다. 따라서 인덱스 0, 2, 4, 6, 8의 요소를 가져옵니다.

만약 시작 인덱스, 끝 인덱스, 인덱스 증가폭을 모두 생략하면 어떻게 될까요?

* `시퀀스객체[::]`
"""

print(a[:])
print(a[::])

"""### 슬라이스의 인덱스 증가폭을 음수로 지정하면?

슬라이스를 사용할 때 인덱스 증가폭을 음수로 지정하면 요소를 뒤에서부터 가져올 수 있습니다. 다음은 리스트 a에서 인덱스 5부터 2까지 1씩 감소시키면서 요소를 가져옵니다.
"""
# 시작점 > 끝점
print(a[5:2:-1])  # 5, 4, 3


"""여기서 주의할 점은 인덱스가 감소하므로 끝 인덱스보다 시작 인덱스를 더 크게 지정해야 한다는 점입니다. 즉, a[5:1:-1]과 같이 시작 인덱스부터 끝 인덱스까지 감소하도록 지정합니다. 그리고 끝 인덱스는 가져오려는 범위에 포함되지 않습니다

특히 다음과 같이 시작 인덱스와 끝 인덱스를 생략하면서 인덱스 증가폭을 -1로 지정하면 어떻게 될까요? 이때는 리스트 전체에서 인덱스를 1씩 감소시키면서 요소를 가져오므로 리스트를 반대로 뒤집습니다.
"""

print(a[::-1])  # -1만 주면 -> 역으로 정렬
print(s[::-1])  # -1만 주면 -> 역으로 정렬

"""물론 이 방법은 리스트뿐만 아니라 모든 시퀀스 객체에 사용할 수 있습니다.

# 딕셔너리
"""
지금까지 살펴봤던 리스트와 튜플은 값 여러 개를 일렬로 저장할 뿐 값끼리 연관 관계가 없었습니다.
"""



"""
파이썬에서는 연관된 값을 묶어서 저장하는 용도로 딕셔너리라는 자료형을 제공합니다.
사전(dictionary)에서 단어를 찾듯이 값을 가져올 수 있다고 하여 딕셔너리라고 부릅니다.
"""

## 딕셔너리 만들기
"""
딕셔너리는 { }(중괄호) 안에 키: 값 형식으로 저장하며 각 키와 값은 ,(콤마)로 구분해줍니다.

* `딕셔너리 = {키1: 값1, 키2: 값2}`
"""
teacher = {"과목" : "파이썬", "결혼": False, "출근거리": 20}
print(teacher)

"""딕셔너리는 키를 먼저 지정하고 :(콜론)을 붙여서 값을 표현합니다. 특히 키에는 값을 하나만 지정할 수 있으며 이런 특성을 따서 키-값 쌍(key-value pair)이라 부릅니다(키-값은 1:1 대응).

### 키 이름이 중복되면?
"""

teacher = {
    "과목" : "파이썬", # 먼저 들어온 '과목' 키의 값은 덮어씌워지고,
    "결혼": False, "출근거리": 20,
    "과목" : "국어", # 과목 (키)가 중복 <- 중복된 키가 최신값으로 업데이트됨.
    "나이": 20, # 20 (값)이 중복
}
print(teacher)

### 값은 어떠한 자료형을 넣어도 상관 없음 (리스트, 딕셔너리....)

"""### 딕셔너리 키의 자료형

딕셔너리의 키는 문자열뿐만 아니라 정수, 실수, 불도 사용할 수 있으며 자료형을 섞어서 사용해도 됩니다. 그리고 값에는 리스트, 딕셔너리 등을 포함하여 모든 자료형을 사용할 수 있습니다.
"""

# 단, 키에는 리스트와 딕셔너리를 사용할 수 없습니다.



# 근데 튜플은 됩니다. -> 리스트를 키로 써주고 싶다? 튜플로 바꿔라...

"""### 빈 딕셔너리 만들기

빈 딕셔너리를 만들 때는 { }만 지정하거나 dict를 사용하면 됩니다. 보통은 { }를 주로 사용합니다.

* `딕셔너리 = {}`
* `딕셔너리 = dict()`
"""





"""## 딕셔너리의 키에 접근하고 값 할당하기"""

# 딕셔너리의 키에 접근할 때는 딕셔너리 뒤에 [ ](대괄호)를 사용하며 [ ] 안에 키를 지정해주면 됩니다.



"""### 딕셔너리에 키를 지정하지 않으면?"""

# 딕셔너리에 키를 지정하지 않은 상태는 해당 딕셔너리 전체를 뜻합니다.
# 따라서 다음과 같이 딕셔너리를 출력하면 { }를 포함하여 딕셔너리 전체가 출력됩니다.

"""### 딕셔너리의 키에 값 할당하기

이제 딕셔너리의 키에 값을 할당해보겠습니다. 딕셔너리는 [ ]로 키에 접근한 뒤 값을 할당합니다.
* `딕셔너리[키] = 값`
"""
d = {}  # 빈 딕셔너리
d['key'] = "value"
print(d)
d['key'] = "value2"
print(d)

"""딕셔너리에서 키의 값을 출력할 때와 마찬가지로 [ ]에 키를 지정한 뒤 값을 할당하면 됩니다. 특히 딕셔너리는 없는 키에 값을 할당하면 해당 키가 추가되고 값이 할당됩니다."""



# 그럼 없는 키에서 값을 가져오려고 하면 어떻게 될까요?
# print(d['key2']) # KeyError: 'key2'

"""### 딕셔너리에 키가 있는지 확인하기

딕셔너리에서 키가 있는지 확인하고 싶다면 in 연산자를 사용하면 됩니다.

* `키 in 딕셔너리`
"""

print("'key' in d", 'key' in d)
print("'key2' in d", 'key2' in d)

"""이처럼 딕셔너리에 특정 키가 있으면 True, 없으면 False가 나옵니다.
반대로 in 앞에 not을 붙이면 특정 키가 없는지 확인합니다.
"""



"""### 해시

딕셔너리는 해시(Hash) 기법을 이용해서 데이터를 저장합니다. 보통 딕셔너리와 같은 키-값 형태의 자료형을 해시, 해시 맵, 해시테이블 등으로 부르기도 합니다.

### 딕셔너리의 키 개수 구하기

딕셔너리를 사용하다 보면 딕셔너리의 키 개수(길이)를 구할 필요가 있습니다. 딕셔너리의 키와 값을 직접 타이핑할 때는 키의 개수를 알기가 쉽습니다. 하지만 실무에서는 함수 등을 사용해서 딕셔너리를 생성하거나 키를 추가하기 때문에 키의 개수가 눈에 보이지 않습니다. 따라서 다음과 같이 키의 개수는 len 함수를 사용하여 구합니다(키와 값은 1:1 관계이므로 키의 개수는 곧 값의 개수입니다).

* `len(딕셔너리)`
"""
print(len(d))


# order = int(input("주문량을 넣어주세요 : ")) # input() -> 문자 -> int(...) 정수
# if order >= 10: # if 조건식: # (:를 많이 잊어요...) -> 조건식은 True 혹은 False로 구성되거나 취급될 수 있는 값.
#     print("주문이 접수되었습니다")  # 들여쓰기 -> 이 들여쓴 코드가 바로 위에 있는 if문에 종속된다 (소속된다) 의미.
# if order < 10:
#     print("10건 이상 주문해주셔야 합니다")

"""만약 if 다음 줄에서 들여쓰기를 하지 않으면 들여쓰기 에러가 발생합니다. 이 항상 이 부분을 주의해주세요.


"""



"""### if 조건문의 기본 형태와 실행 흐름 알아보기

이제 if 조건문을 자세히 알아보겠습니다. 파이썬에서 if 조건문은 if 조건식: 형식으로 사용하며 그다음 줄에는 들여쓰기를 한 뒤 조건식이 만족할 때 실행할 코드를 넣습니다. 특히 이 조건식이 만족할 때 실행할 코드를 if 본문(if body)이라고 부릅니다.

여기서는 변수 x에 10을 할당한 뒤 if 조건문으로 x가 10과 같은지 검사하였습니다. 조건식은 x == 10과 같은 형식으로 지정해주는데 ==은 두 값이 "같을 때" 라는 뜻입니다.

즉, if x == 10:은 x가 10과 같은지 비교한 뒤 같으면 다음에 오는 코드를 실행하라는 뜻이 됩니다. 따라서 x는 10이고 조건식을 만족하므로 그다음 줄의 print가 실행되어 '10입니다.'가 출력됩니다.

보통 if의 조건식이 만족하면 참( True), 만족하지 않으면 거짓(False)이라고 부릅니다.

### if 조건문을 사용할 때 주의할 점

if 조건문을 사용할 때 주의할 점이 있는데 파이썬에서는 =을 할당으로 사용하고 있으므로 값을 비교할 때는 =을 두 개 붙여서 ==로 사용해야 합니다. 자주 틀리는 부분이니 `if`**안에서 ==을 사용했는지 반드시 확인하세요. 다음과 같이 if에 =을 사용하면 문법 에러가 발생합니다.**
"""
# order = input("주문하고자 하는 음료를 입력해주세요 (콜라) :")
# if order == "콜라":
# # if order = "콜라":  # SyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?
#     print("콜라 드릴게요")


"""### if 조건문에서 코드를 생략하기"""
age = 20
if age >= 20:
    # java... {} 상관없어요...
    # 파이썬 문제? -> 들여쓰기라서 -> 아무코드를 입력하면 버그로 인식
    pass # 들여쓰기 포맷을 유지 (코드 블록을 유지시키기 위한 코드) # {} -> 코드블록.
    # TODO : 앞으로 할 일.

"""if 다음 줄에 pass라는 특별한 키워드를 넣었습니다. 여기서 pass는 아무 일도 하지 않고 그냥 넘어간다는 뜻입니다. 파이썬에서는 if 다음 줄에 아무 코드도 넣지 않으면 에러가 발생하므로 if 조건문의 형태를 유지하기 위해 pass를 사용합니다.

pass는 아무 일도 하지 않는 코드라서 의미가 없을 것 같지만 나중에 작성해야 할 코드를 표시할 때 사용할 수 있습니다. 즉, 다음과 같이 pass만 넣고 나중에 할 일은 주석으로 남겨놓는 방식입니다.
"""



## if 조건문과 들여쓰기
"""

## 중첩 if 조건문 사용하기

지금까지 if를 한 번만 사용하는 단순한 조건문을 사용했습니다. 하지만 프로그래밍을 하다 보면 if를 여러 번 사용하는 복잡한 조건도 자주 나옵니다. 이번에는 if를 여러 번 사용하는 중첩 if 조건문을 사용해보겠습니다. 다음은 변수의 값이 10 이상이면 '10 이상입니다.'를 출력한 뒤 15이면 '15입니다.', 20이면 '20입니다.'를 출력합니다.
"""

# age = 15
age = 20
age = 13
print("age", age)
if age < 20:
    print("어린이")
    if age > 13 and age < 17:
        print("중학생")

color = "red"
# money = 10000
money = 5000
print(color, money)
if color == "red":
    if money >= 10000:
        print("사과를 먹는다")
    if money < 10000:
        print("사과를 좋아하지만 못 먹는다")

age = 19
if age >= 20: # True를 만족시키지 않는다면 (조건식)
    print("술 주문이 가능합니다")
# if age < 20:
# if not (age >= 20):
else: # age < 20
    print("술 주문이 어렵습니다")


"""### if와 else의 기본 형태와 실행 흐름 알아보기

else는 if의 조건식이 만족하지 않을 때 코드를 실행합니다. 여기서는 x에 5가 들어있어서 x == 10을 만족하지 않으므로 else의 print가 실행되어 '10이 아닙니다.'가 출력됩니다.

즉, 조건식이 참(True)이면 if의 코드(if 본문)가 실행되고, 거짓(False)이면 else의 코드(else 본문)가 실행됩니다.

### 변수에 값 할당을 if, else로 축약하기 (삼항연산자)
"""
# number = "991111-1111111"
number = "991111-2111111"
gender = ""
if number[7] == "1":
    gender = "남성"
else:
    gender = "여성"
print(gender)

# gender는 if 조건을 만족시킨다면 "남성"이야, if 조건을 만족시키지 않는다면 else야.
gender = "남성" if number[7] == "1" else "여성" # 참일 때의 결과 if 조건식 else 거짓일 때의 결과.
# 조건식 ? 참일 때 결과 : 거짓일 때 결과 <- 자바스크립트, 자바.
print(gender)
a, b, c = [1, 2, 3]
print("a", a)
print("b", b)
print("c", c) # 언팩킹
a, b, c = "xyz"
print("a", a)
print("b", b)
print("c", c) # 언팩킹

